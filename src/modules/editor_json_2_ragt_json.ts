import * as cheerio from 'cheerio';
import { useLocale } from '../locale';
import {
  convertRagtJsonTextToHyperlink,
  dfsTree,
  getMetaByDfs,
  splitSentences,
} from '../utils/converter';
import { BLOCK_TYPE, CLASS_NAME } from '../constant';

export const editorJson2RagtJson = (editorJson) => {
  const metaOpt = editorJson?.metaOpt || {};
  const lang = metaOpt?.lang || 'en';
  const getListAnnotation = (data) => {
    let itemsArr = [];
    dfsTree(data, itemsArr);

    itemsArr = itemsArr.filter((item) => item);
    return useLocale({
      key: 'ListIntroduction',
      lang,
      value: {
        style: data?.style,
        rootItemNum: data?.items?.length,
        subItemNum: itemsArr?.length - data?.items?.length,
      },
    });
  };

  const buildMetaTable = (data) => {
    const withHeadings = data.withHeadings;
    const content = [...data.content];
    const totalRows = content?.length ?? 0;
    const totalCols = content[0]?.length ?? 0;

    const annotation = useLocale({
      key: 'TableIntroduction',
      lang,
      value: { totalRows, totalCols },
    });
    const meta: any = [
      {
        id: Math.random().toString(36).substring(7),
        ui: annotation,
        polly: cheerio?.load(annotation)?.text(),
        ssml: '',
        user: '',
        actions: [],
        isAutogenerated: true,
        soundType: 'polly',
      },
    ];

    if (data.caption) {
      const caption = useLocale({
        key: 'TableCaptionForDisplay',
        lang,
        value: { caption: data.caption },
      });
      meta.push({
        id: Math.random().toString(36).substring(7),
        ui: data?.caption,
        polly: cheerio?.load(caption)?.text(),
        ssml: '',
        user: '',
        actions: [],
        isAutogenerated: true,
        soundType: 'polly',
      });
    }

    let index = 0;
    content.forEach((row, idx) => {
      let polly = '';
      if (idx === 0 && withHeadings) {
        const header = row
          .filter((item) => item?.data)
          .map((item) => item.data)
          .join(', ');
        polly = useLocale({
          key: 'TableHeader',
          lang,
          value: { header },
        });
        index += 1;
      } else if (idx === 0 && !withHeadings) {
        const rowData = row
          .filter((item) => item?.data)
          .map((item) => item.data)
          .join(', ');
        polly = useLocale({
          key: 'TableFirstLine',
          lang,
          value: { rowData },
        });
        index += 2;
      } else {
        const rowData = row
          .filter((item) => item?.data)
          .map((item) => item.data)
          .join(', ');
        polly = useLocale({
          key: index === 1 ? 'TableFirstLine' : 'TableOtherLine',
          lang,
          value: { rowData, line: index, isEndRow: idx === content.length - 1 },
        });
        index += 1;
      }

      polly = cheerio
        .load(
          polly.replace(
            /<br\s*\/?>/g,
            useLocale({
              key: 'Dot',
              lang,
            })
          )
        )
        .text();
      let ui = `<tr tabindex="0" aria-label="${polly}">`;
      row.forEach((cell) => {
        const className =
          withHeadings && idx === 0 ? `class="${CLASS_NAME.tableHeader}"` : '';
        ui += `<td ${className} aria-hidden="true" ${
          cell.rowSpan ? `rowspan="${cell.rowSpan}"` : ''
        } ${cell.colSpan ? `colspan="${cell.colSpan}"` : ''}>${cell.data}</td>`;
      });
      ui = ui.concat('</tr>');
      meta.push({
        ui,
        polly,
        ssml: '',
        user: '',
        actions: [],
        soundType: 'polly',
      });
    });

    const tableEnd = useLocale({ key: 'TableEnd', lang, value: '' });
    meta.push({
      id: Math.random().toString(36).substring(7),
      ui: tableEnd,
      polly: tableEnd,
      ssml: '',
      user: '',
      actions: [],
      isAutogenerated: true,
      soundType: 'polly',
    });
    return meta;
  };

  // TODO: Generate meta data for each block
  const blocks = (editorJson?.blocks || []).map((block) => {
    let meta: any = [];
    // TODO: Paragraph, Header
    if ([BLOCK_TYPE.HEADER, BLOCK_TYPE.PARAGRAPH].includes(block.type)) {
      const sentences = splitSentences(block.data.text, lang);
      meta = sentences.map((sentence) => {
        const htmlTagRegex = /<\/?[a-z][a-z0-9]*[^<>]*>|<!--.*?-->/gim;
        const aTagRegex =
          /<a.+?\s*href\s*=\s*["\']?(?<href>[^"\'\s>]+)["\']?/gi;
        return {
          ui: sentence.replace('\n', '<br >'),
          polly: sentence.replace(htmlTagRegex, ''),
          ssml: '',
          user: '',
          actions: [...sentence.matchAll(aTagRegex)]
            .map((item) => item.groups?.href)
            .filter((item) => !!item),
          soundType: 'polly',
        };
      });
    }

    // TODO: List
    if (block.type === BLOCK_TYPE.LIST) {
      let items = [];
      getMetaByDfs({ data: block.data, parentId: 'root', resultArr: items });
      meta = [...items];
      meta = [
        {
          polly: getListAnnotation(block.data),
          ssml: '',
          user: '',
          actions: [],
          isAutogenerated: true,
          soundType: 'polly',
        },
        ...meta,
      ];
    }

    // TODO: Image
    if (block.type === BLOCK_TYPE.IMAGE) {
      const imageAnnotation = useLocale({
        key: 'ImageAnnotation',
        lang,
        value: { alt: block.data.caption },
      });
      meta = [
        {
          ui: imageAnnotation,
          polly: cheerio?.load(imageAnnotation)?.text(),
          ssml: '',
          user: '',
          actions: [],
          soundType: 'polly',
        },
      ];
    }

    // TODO: Table
    if (block.type === BLOCK_TYPE.TABLE) {
      meta = buildMetaTable(block.data);
      block.data = {
        withHeadings: block?.data?.withHeadings,
        content: block.data?.content || [],
        caption: block.data?.caption || '',
      };
    }
    return {
      ...block,
      meta,
    };
  });

  const ragtJson = convertRagtJsonTextToHyperlink({ ...editorJson, blocks });
  return ragtJson;
};
